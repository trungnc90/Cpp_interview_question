{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf840
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red0\green0\blue0;\red11\green86\blue1;
}
{\*\expandedcolortbl;;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0\c84314;\cssrgb\c0\c40000\c0;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww24180\viewh14580\viewkind0
\deftab720
\pard\pardeftab720\parhyphenfactor20\partightenfactor0

\f0\b\fs32 \cf0 \cb2 \expnd0\expndtw0\kerning0
1. What are the differences between references and pointers?\
\
\pard\pardeftab720\parhyphenfactor20\partightenfactor0

\b0 \cf0 \cb2 References are less powerful than pointers\cb1 \
\pard\pardeftab720\qj\parhyphenfactor20\partightenfactor0
\cf0 \cb2 1) Once a reference is created, it cannot be later made to reference another object; it cannot be reseated. This is often done with pointers.\cb1 \
\cb2 2) References cannot be NULL. Pointers are often made NULL to indicate that they are not pointing to any valid thing.\cb1 \
\cb2 3) A reference must be initialized when declared. There is no such restriction with pointers\
\
\pard\pardeftab720\parhyphenfactor20\partightenfactor0

\b \cf0 \cb2 2. What are virtual functions\
\
\pard\pardeftab720\qj\parhyphenfactor20\partightenfactor0

\b0 \cf0 \cb2 A virtual function is a member function which is declared within a base class and is re-defined(Overriden) by a derived class.\
\

\b \cb2 Rules for Virtual Functions
\b0 \cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\qj\parhyphenfactor20\partightenfactor0
\ls1\ilvl0\cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	1	}\expnd0\expndtw0\kerning0
Virtual functions cannot be static and also cannot be a friend function of another class.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	2	}\expnd0\expndtw0\kerning0
Virtual functions should be accessed using pointer or reference of base class type to achieve run time polymorphism.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	3	}\expnd0\expndtw0\kerning0
The prototype of virtual functions should be same in base as well as derived class.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	4	}\expnd0\expndtw0\kerning0
They are always defined in base class and overridden in derived class. It is not mandatory for derived class to override (or re-define the virtual function), in that case base class version of function is used.\cb1 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	5	}\expnd0\expndtw0\kerning0
A class may have {\field{\*\fldinst{HYPERLINK "https://www.geeksforgeeks.org/virtual-destructor/"}}{\fldrslt \cf4 virtual destructor}} but it cannot have a virtual constructor.\
\pard\tx720\pardeftab720\qj\parhyphenfactor20\partightenfactor0
\cf0 \
// CPP program to illustrate \
// concept of Virtual Functions \
\
#include <iostream> \
using namespace std; \
\
class base \{ \
public: \
	virtual void print() \
	\{ \
		cout << "print base class" << endl; \
	\} \
\
	void show() \
	\{ \
		cout << "show base class" << endl; \
	\} \
\}; \
\
class derived : public base \{ \
public: \
	void print() \
	\{ \
		cout << "print derived class" << endl; \
	\} \
\
	void show() \
	\{ \
		cout << "show derived class" << endl; \
	\} \
\}; \
\
int main() \
\{ \
	base* bptr; \
	derived d; \
	bptr = &d; \
\
	// virtual function, binded at runtime \
	bptr->print(); \
\
	// Non-virtual function, binded at compile time \
	bptr->show(); \
\} \
\
\
}